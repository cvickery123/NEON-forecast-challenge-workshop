---
title: "forecast_Project1"
author: "Caroline Vickery"
date: "2024-02-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-packages, echo = F, warning=F, message=F}
#install.packages('remotes')
#install.packages('fpp3') # package for applying simple forecasting methods
#install.packages('tsibble') # package for dealing with time series data sets and tsibble objects
#nstall.packages('tidyverse') # collection of R packages for data manipulation, analysis, and visualisation
#install.packages('lubridate') # working with dates and times
#remotes::install_github('eco4cast/neon4cast') # package from NEON4cast challenge organisers to assist with forecast building and submission
# update.packages(ask = FALSE)
# Load packages
library(tidyverse)
library(lubridate)

set.seed(101)
```

```{r get-targets, message=F}
#read in the targets data
targets <- read_csv('https://data.ecoforecast.org/neon4cast-targets/aquatics/aquatics-targets.csv.gz')

# read in the sites data
aquatic_sites <- read_csv("https://raw.githubusercontent.com/eco4cast/neon4cast-targets/main/NEON_Field_Site_Metadata_20220412.csv") |>
  dplyr::filter(aquatics == 1)

lake_sites <- aquatic_sites %>%
  filter(field_site_subtype == 'Lake')

# Filter the targets
targets <- targets %>%
  filter(site_id %in% lake_sites$field_site_id,
         variable == 'temperature')
```


```{r get-NOAA-past, message = F}

# Past stacked weather
noaa_past_s3 <- neon4cast::noaa_stage3()

variables <- c("air_temperature", "relative_humidity", "eastward_wind", "northward_wind")
#Other variable names can be found at https://projects.ecoforecast.org/neon4cast-docs/Shared-Forecast-Drivers.html#stage-3

noaa_past <- noaa_past_s3  |> 
  dplyr::filter(site_id %in% lake_sites$field_site_id,
                datetime >= ymd('2017-01-01'),
                variable %in% variables) |> 
  dplyr::collect()

# aggregate the past to mean values
noaa_past_mean <- noaa_past |> 
  mutate(datetime = as_date(datetime)) |> 
  group_by(datetime, site_id, variable) |> 
  summarize(prediction = mean(prediction, na.rm = TRUE), .groups = "drop") |> 
  pivot_wider(names_from = variable, values_from = prediction) |> 
  # convert air temp to C
  mutate(air_temperature = air_temperature - 273.15)

noaa_past_mean$windspeed<-sqrt(noaa_past_mean$eastward_wind^2 + noaa_past_mean$northward_wind^2)

```

```{r get-NOAA-future, message = F}
# Future weather
# New forecast only available at 5am UTC the next day
forecast_date <- Sys.Date() 
noaa_date <- forecast_date - days(1)

noaa_future_s3 <- neon4cast::noaa_stage2(start_date = as.character(noaa_date))
variables <- c("air_temperature", "relative_humidity", "eastward_wind", "northward_wind")

noaa_future <- noaa_future_s3 |> 
  dplyr::filter(datetime >= forecast_date,
                site_id %in% lake_sites$field_site_id,
                variable %in% variables) |> 
  collect()

noaa_future_daily <- noaa_future |> 
  mutate(datetime = as_date(datetime)) |> 
  # mean daily forecasts at each site per ensemble
  group_by(datetime, site_id, parameter, variable) |> 
  summarize(prediction = mean(prediction)) |>
  pivot_wider(names_from = variable, values_from = prediction) |>
  # convert to Celsius
  mutate(air_temperature = air_temperature - 273.15) 

noaa_future_daily$windspeed<-sqrt(noaa_future_daily$eastward_wind^2 + noaa_future_daily$northward_wind^2)

combined_met_df1 <- bind_rows(noaa_past_mean, noaa_future_daily)

jasontest<-combined_met_df1 %>% 
  arrange(site_id, parameter, datetime) %>% 
  group_by(site_id, parameter) %>%
  mutate(airtemp_1daylag = lag(air_temperature)) #correct way to lag 
jasontest$datetimeplus1<-jasontest$datetime + days(1)
colnames(jasontest)<-c("airtemp_1daylag", "realdatetime", "site_id", "parameter",  "datetime")
view(jasontest)
derulotest<-left_join(combined_met_df1, jasontest, by=c("datetime", "site_id", "parameter")) 

#filling in the gaps - Sys.Date data is missing airtemp_1daylag
cyrus_df<-NULL


for(i in 1:length(lake_sites$field_site_id)){
  curr_site <- lake_sites$field_site_id[i]
  
  currentrow<-derulotest %>% filter(datetime==Sys.Date(), site_id==curr_site,
                                    airtemp_1daylag!=is.na(airtemp_1daylag))
  
  airtemptopaste<-currentrow$airtemp_1daylag
  realdatetopaste<-currentrow$realdatetime

  mileytest<-derulotest %>% filter(datetime==Sys.Date(),
                                 site_id==curr_site) %>% 
    select(datetime, site_id, parameter, airtemp_1daylag, realdatetime)

  party<-mileytest %>% filter(parameter>=0)
  
  party$airtemp_1daylag<-airtemptopaste
  party$realdatetime<-realdatetopaste
  
  cyrus_df<-dplyr::bind_rows(party, cyrus_df)
}


derulotest2<-left_join(derulotest, cyrus_df, by=c("datetime", "site_id", "parameter")) 

derulotest2<-derulotest2 %>% select(order(colnames(.))) %>% unite("airtemp_1daylag", airtemp_1daylag.x:airtemp_1daylag.y, na.rm = TRUE, remove = FALSE)
derulotest2<-derulotest2 %>% unite("realdatetime", realdatetime.x:realdatetime.y, na.rm = TRUE, remove = FALSE)

#derulotest2 %>% filter(datetime==Sys.Date()) %>% view()

derulotest2<-derulotest2 %>% select(-c(airtemp_1daylag.x, airtemp_1daylag.y, realdatetime.x, realdatetime.y))

derulotest2$airtemp_1daylag<-as.numeric(derulotest2$airtemp_1daylag)
```

```{r model-setup}
# Generate a dataframe to fit the model to 
targets_lm <- targets |> 
  filter(variable == 'temperature') |>
  pivot_wider(names_from = 'variable', values_from = 'observation') |> 
  left_join(derulotest2, 
            by = c("datetime","site_id"))

```

```{r forecast-loop with uncertainty}

forecast_horizon <- 30
forecast_dates <- seq(from = ymd(forecast_date), to = ymd(forecast_date) + forecast_horizon, by = "day")
n_members <- 31

forecast_df <- NULL
###NEXT STEP: REMOVE NAs FROM MOD WITHOUT CREATING ALL NAs
for(i in 1:length(lake_sites$field_site_id)) {  
  
  curr_site <- lake_sites$field_site_id[i]
  
  # Get only the necessary data for the specific site
  site_target <- targets_lm |>
    filter(site_id == curr_site,
           datetime <= ymd(forecast_date))

  noaa_future_site <- derulotest2 |> 
    filter(site_id == curr_site,
           datetime >= ymd(forecast_date), 
           parameter != is.na(parameter)) 
  
  #Fit linear model based on past data: water temperature = m * air temperature + b
  fit <- lm(site_target$temperature ~ site_target$airtemp_1daylag + site_target$relative_humidity)
    
  #parameter uncertainty  
  summary_fit<-summary(fit)
coeffs <- round(fit$coefficients, 3)

params_se <- summary_fit$coefficients[,2]
#IN-CLASS EXPLANATION: we want these to be different for each site but the same throughout the forecast horizon. That is why these lines are within the first for loop but outside the second. 
param_df <- data.frame(beta1 = rnorm(n_members, coeffs[1], params_se[1]),
                       beta2 = rnorm(n_members, coeffs[2], params_se[2]),
                       beta3 = rnorm(n_members, coeffs[3], params_se[3]))

#process uncertainty
mod <- predict(fit, site_target)
residuals <- mod - site_target$temperature

sigma <- sd(residuals, na.rm = TRUE) # Process Uncertainty Noise Std Dev.; this is your sigma
  
  # Loop through all forecast dates
  for (t in 1:length(forecast_dates)) {
  
  #pull driver ensemble for the relevant date; here we are using all 30 NOAA ensemble members
  site_drivers <- noaa_future_site %>%
    filter(datetime == forecast_dates[t])
  
  # use linear regression to forecast water temperature for each ensemble member
  forecasted_temperature <- param_df$beta1 + param_df$beta2 * site_drivers$airtemp_1daylag + site_drivers$relative_humidity * param_df$beta3 + rnorm(n_members, mean = 0, sd = sigma)

  
  # put all the relevant information into a tibble that we can bind together
  curr_site_df <- tibble(datetime = rep(forecast_dates[t], times = n_members),
                         site_id = curr_site,
                         parameter = 1:n_members,
                         prediction = forecasted_temperature,
                         variable = "temperature") 
  
  forecast_df <- dplyr::bind_rows(forecast_df, curr_site_df)
  
  }
  
  message(curr_site, 'forecast run')
}

```

```{r make-standard}
# Make forecast fit the EFI standards
# Remember to change the model_id when you make changes to the model structure!
my_model_id <- 'Vickery_project1'

forecast_df_EFI <- forecast_df %>%
  filter(datetime > forecast_date) %>%
  mutate(model_id = my_model_id,
         reference_datetime = forecast_date,
         family = 'ensemble',
         parameter = as.character(parameter)) %>%
  select(datetime, reference_datetime, site_id, family, parameter, variable, prediction, model_id)

```

```{r plot-forecast}
forecast_df_EFI |> 
  ggplot(aes(x=datetime, y=prediction, group = parameter)) +
  geom_line() +
  facet_wrap(~site_id) +
  labs(title = paste0('Forecast generated for ', forecast_df_EFI$variable[1], ' on ', forecast_df_EFI$reference_datetime[1]))
```
